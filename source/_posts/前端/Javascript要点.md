---
title: Javascript要点
tags:
  - 前端
  - JavaScript
categories: 前端
abbrlink: 67a2d32c
date: 2024-01-12 14:24:40
cover:
---
# Javascript要点

## 编写位置

可以在html结构中直接写入onclick中，或者href中；也可以在外部写js文件，之后使用script标签中的src属性直接引入。但是要注意如果使用了这种方式编写script标签后，这个标签就不能用来写内部js代码了，想要再编写内部的js代码，可以再写一个script标签。

## 标识符

包括变量名、函数名、属性名等。

命名要求：可以含有字母、数字、下划线、$。但是不能以数字开头，不能是关键字和保留字。一般采用驼峰命名法。

## 数据类型以及运算

JS中包括的数据类型有：

* String
* Number
* BigInt（用n结尾）
* Boolean
* Null
* Undefined
* Symbol
* Object

前七个属于基本数据类型，也叫原始值。Object属于引用数据类型。

可以用typeof关键字来检查一个变量的类型。

### 类型转换

将a变量转换为String：

1. 使用toString()方法，a.toString()。但是null和undefined没有该方法。
2. 调用String()函数,String(a)。可以转换null和undefined。
3. 将数据加上一个空字符串，也可以实现转化。

将a变量转换为Number：

1. 使用Number函数，Number(a)。如果字符串中含有非数字内容，会转换为NaN；如果是空字符串，转换为0。布尔值转数字是对应的1和0，null是0，undefined是NaN。
2. parseInt()，用于将一个字符串转换为int，同理parseFloat转换为float。这个函数只将字符串开头的有效部分转化为字符串。如果对于非String类型，会先转化为String再操作。
   parseInt函数中可以传递第二个参数，表示转化为几进制。
3. 将变量减0，或者乘1，也可以实现转化。
4. 在变量前加一个`+`，会将其转化为Number变量。甚至可以实现1++"2"来实现数字3。（这js真是及其不严谨）

将a变量转换为Boolean：

1. 调用Boolean()函数。对于数字，除了0和NaN是false，其他是true；对于字符串，除了空字符串是false，其余是true；对于null和undefined，转换为false。对象也会转换为true。

### 相关的一些杂项

1. JS中的Number有最大值，可以使用Number.MAX_VALUE来看。如果超过了最大值，就会返回一个"Infinity"。也可以使用Infinity来给变量赋值。
   也有0以上的最小正值，使用Number.MIN_VALUE来看。
2. NaN是一个特殊的数字，表示not a number，表示不是一个数字，但是这是一个number类型的关键字。
3. JS中整数的运算基本可以保证正确，但是浮点数的运算会失去精度。所以不能用js来进行精度要求高的运算。
4. Null类型的值就是null，用来表示一个空的对象。但是使用typeof检查会返回一个object。
5. Undefined类型的变量就一个是undefined，是声明一个变量但是不赋值。而且typeof检查返回的也是undefined。

### 运算相关

1. 任何值和字符串相加都会先转化为字符串再拼接，如果是两个字符串用相加，会直接拼接字符串。
   除了以上的相加情况以外，其他任何情况，当对非Number类型进行算数运算时，会先将其转化为Number值再计算，但是任何值和NaN计算都是NaN。
2. 同理，在进行一些别的运算，例如逻辑运算的时候，如果不是布尔值，会首先进行数据类型转化。
   不过逻辑运算实现断路运算，如果第一个值不符合条件，就不看第二个值，和java的双逻辑符一样。
3. 与运算如果两个值都是true，会返回靠后面的值。如果有false，就返回靠前的false。
   或运算相反。
4. 比较运算的时候也会先转化为数字，并将比较结果返回为布尔值。但是字符串之间的比较是一位一位比较字典序。所以要注意如果想进行数字方面的比较要先转换。
5. a ** b是a的b次方。

### 相等判断

#### ==

对于`==`，如果两者的数据类型不同，会先转换成相同的数据类型。大部分情况都是转化成数字再比较。

但是有特例，例如`null==0`，返回的是false；以及undefined是从null中衍生出来的，两者相等；NaN不和任何值相等，包括它本身。

所以判断一个值是否是NaN需要使用isNaN()函数。

当比较对象的时候，是比较是否是同一个对象。

#### ===

全等，判断是否全等，是不做类型转换的。

注意undefined和null不全等。

## 对象相关

创建对象：`var obj = new Object();`，或者使用常量创建：`var obj = {};`，用第二种的时候可以在创建的时候就指定一些里面的值，用`,`隔开。

和python一样，增加属性的时候，可以使用`obj.name=...;`来添加，删除的时候是`delete obj.name`。

在使用一个特殊的属性名，例如想要使用`123`来作为属性名，需要使用`obj["123"]`来操作属性。`[]`的运算优先级是最高一档的，可以在里面写表达式。

对象保存在堆中，在使用赋值运算符`=`的时候是地址拷贝。如果将变量值设置为null，只是断开了地址联系，不会影响原来对象的值。

访问一个对象中没有的属性的时候不会报错而是会返回undefined。

### in运算符

可以用`"dede" in obj`来判断对象中是否存在dede这个属性。

无论属性在对象自身中还是在原型中，都会返回true。

如果只想检查是否在自身中，使用`Object.hanOwn(对象，属性)`。

### 枚举对象语句

`for(var 变量 in 对象){语句}`。

这个变量是对象的属性，想要取出属性对应的值需要用`对象[属性名]`。

### 对象存储结构

对象存储的空间分为两部分：

1. 对象自身：
   包括直接通过对象添加的属性，和在类中通过`x = y;`添加的属性。
2. 原型对象(prototype)
   对象中还有一些内容，会存储在原型对象中。
   在对象中有一个属性指向其原型对象，即`__proto__`。
   在访问对象属性的时候，会优先访问对象自身，如果没有，就会去原型对象中找。
   会添加到原型对象中的情况：
   1. 在类中通过`xxx(){...}`声明的方法，位于原型中。
   2. 主动向原型中添加的属性或方法。

### 原型对象

访问原型对象：`p.__proto__`和`Object.getPrototypeOf(p)`。都是访问p对象的原型对象。或者类的`prototype`属性。

内部数据：

1. 对象中的数据（属性、方法等）；
2. 对象的构造函数。

原型对象也有原型对象，构成了原型链。
有类的p对象--> 原型-->原型-->null。
一个空的obj对象（也就是Object对象）-->原型-->null。

所有的同类型对象的原型都是同一个。那么同类型对象的原型链都是一样的。这样对于所有的同类对象，就只需要创建一个原型就行了。

js中的继承是用过原型实现的，子类的原型是父类的一个实例。

原型尽量不要去改，要改也是通过类的`prototype`属性赋值。

### 复制对象



## 函数相关

函数也是一个对象，所以也可以当作参数被传递。。

创建函数`var fun = new Function();`，但是基本不使用。一般使用的是`function fun(形参){语句... return...}`，或者`const fun = function(形参){语句...return ...}`，或者使用箭头函数`const fun = () => {语句...}`，箭头函数最常用。

如果没有return，就是返回一个undefined。

函数可以嵌套，return也可以返回一个函数。

调用函数除了使用fn()方式，也可以使用fn.call()以及fn.apply()。使用后两种方法可以指定函数中的this，如果不指定，函数中的this就是window对象，call和apply中的第一个参数，将会成为函数的this。

call调用，函数的实参直接在第一个参数后一个一个列出来；apply调用，函数的实参需要通过一个数组加在函数的第一个参数后面。

但是箭头函数没有自己的this，无法改变。

### 立即执行函数

```javascript
(function(形参){语句})(实参);
```

函数也可以是对象的属性，这种函数被称为对象的方法。

这样可以避免变量冲突的问题。

### 参数相关

形参多于实参，多的形参会赋值为undefined；实参多于形参，多余的实参不使用。

形参可以指定默认值。

### 箭头函数

([参数]) => 返回值

- 无参箭头函数:() => 返回值
- 一个参数的:a => 返回值
- 多个参数的:(a,b) => 返回值
- 只有一个语句的函数:() => 返回值
- 只返回一个对象的函数:() => ({...})
- 有多行语句的函数:() => {...}

如果箭头函数只有一个语句，直接写返回值，可以直接写在箭头后面。其他还是return。

### window对象

在浏览器中，浏览器提供了一个window对象，可以直接访问。

window对象代表的是浏览器窗口，通过该对象可以对浏览器窗口进行操作。并且window对象还负责储存js中的内置对象和浏览器的宿主对象。

window对象的属性可以通过window对象访问，也可以直接访问，函数可以认为是window对象的方法。

在全局中使用var声明的变量，会作为window对象的属性，使用function声明的函数，会作为window对象的方法。
使用let声明的变量不会存储在window对象中。

### 回调函数

函数的参数也可以是函数，如果将函数作为参数传递，我们就称这个函数为回调函数。

通常回调函数都是匿名函数。

### 高阶函数

如果一个函数的参数或者返回值是函数，则这个函数就称为高阶函数。

将函数作为参数，就可以动态地向函数中传递代码。作为返回值，可以动态地生成函数。

### 闭包

可以利用函数，来隐藏不希望被外部访问的变量。例如：

```js
function outer(){
    let num = 0;
    return () => {
        num++;
    }
}
const fn = outer();
```

这样就实现了一个功能：fn是一个函数，每调用这个函数一次，num就自增1，并且这个num不是全局变量，不会被外部访问。

闭包是一个能够访问到外部函数作用域的函数。如上return的函数就是一个闭包。当我们需要隐藏一些内容的时候可以使用

闭包要素：1. 函数的嵌套；2. 内部函数需要引用外部函数的变量；3.内部函数要作为返回值返回。

闭包生命周期：闭包在外部函数调用的时候产生，每一次调用外部函数都会产生一个新的闭包；当内部函数丢失时销毁。

### arguments和可变参数

arguments是函数中一个隐含参数，是一个类数组对象，可以通过索引访问，用来存储函数的实参，类似于argv。这样可以通过arguments对象直接访问实参。

只能使用forof语句遍历，但是由于不是数组，不能调用数组方法。

可以实现不受参数数量限制的函数。

箭头函数中没有arguments。

可变参数：

```js
function fn(...args){
	...
}
```

也就是变长参数，将所有参数都存在args这个数组中，args名字自定义。并且这是一个数组，可以使用数组方法。

同样可以配合其他参数使用。

### bind

是一个高阶函数，可以用来创建一个新的函数。

bind可以为新函数绑定this。传入一个参数，将这个参数作为新函数永久的this，不论以什么形式调用新函数，this永远是这个。

也可以用来绑定参数，如果在bind第一个参数后面再加参数，那么函数的对应位置的参数值绑定不变。

但是箭头函数没有自己的this，无法改变。

## 类相关

定义：

`class 类名{...}`或者`const 类名 = class{...}`。

和Java不同，如果使用static修饰属性成为静态属性，就只能通过类访问，无法通过实例访问。

构造方法使用`constructor(参数){...}`。在内部使用的也是this.属性=...，那么相当于也是对对象添加属性，所以，如果不是私有属性，就可以省略属性在类中的声明。

### get和set方法

js提供的独特的get和set方法（依托答辩）。

```js
class P{
    #name
    
    get name(){
        return this.#name
    }
    set name(name){
        this.#name = name
    }
}

//get调用
const p = new P();
p.name;
//set调用
p.name = "答辩";
```

### 封装

私有化是在属性前面加一个`#`，只能在类的内部访问，不能通过对象实例访问。私有属性必须在类中声明之后才能在构造函数中访问。

### 继承

继承也是extands。继承中子类也是写同名方法来重写。重写构造函数第一行同样需要`super();`。调用父类方法也是`super.方法()`。

### 多态

遗憾的是，js中如果重载函数，方法名相同的情况下，后写的方法会直接覆盖前写的方法。js中多态指的概念是可以直接将对象当作参数，并不检验参数的类型。

## 数组

数组中可以存储任意的数据类型，尽量一个数组中类型相同。

**创建**：

`const arr = new Array()`,或者`const arr = []`。

**添加元素**：

`数组[索引] = 值`。如果跳着赋值，中间会有空属性。

读取的时候如果读取不存在的元素会返回undefined。

有length属性判断长度。

**遍历**

`for(let a of array){...}`。这样遍历相当于增强for循环。

这个语句只要是可迭代对象都能遍历，例如字符串。

### 一些方法

`Array.isArray()`，判断是否是数组。

`at()`，可以根据索引获取数组中指定元素，可以给负值，代表从后往前。

`concat()`，连接数组。`arr.concat(arr2,...)`，这是一种非破坏方法，不改变原数组的值，而是返回一个新数组。

`indexOf()`，返回元素第一次出现的索引位置。可以多传一个值表示查询的起始位置。同样也有`lastIndexOf()`。没找到返回-1.

`join()`，将数组中所有元素拼接成字符串，可以传入参数表示连接符，默认是`,`。

`slice()`，截取数组。第一个参数是起始位置，第二个元素是结束位置（不包括结束的元素）。也是非破坏性方法。第二个参数省略会一直截取到最后。也可以传负值，也是倒数第几个。
如果什么参数都不传，就是实现了对数组的浅拷贝。

`filter()`，过滤，将数组中满足条件的元素保存到一个新数组中返回。需要一个回调函数作为参数，如果回调函数返回true，就会放入新数组。这个回调函数有三个参数，第一个是数组元素，第二个是索引，第三个是当前被遍历的数组。

`map()`，根据当前数组生成一个新数组。需要一个回调函数作为参数，回调函数的返回值会作为新数组的元素。这个回调函数有三个参数，第一个是数组元素，第二个是索引，第三个是当前被遍历的数组。

`forEach()`，用来遍历数组。需要一个回调函数作为参数。数组中有几个元素，回调函数就会调用几次，每次调用都会将数组中的元素作为参数传递。这个回调函数有三个参数，第一个是数组元素，第二个是索引，第三个是当前被遍历的数组。

`reduce()`，可以将数组中所有元素整合成一个值。需要一个回调函数作为参数，需要两个参数，例如`arr.reduce((a,b) => a+b);`就是从第一个元素开始，第一个元素是a，第二个是b，求一次a+b；然后将求和结果作为a，第三个元素作为b，依次类推。
还可以传入一个参数，将这个参数作为a的起始值。

### 一些破坏性方法

`push()`，推进尾部一个元素。

`pop()`，出栈一个元素。

`unshift()`，向数组开头添加一个或多个元素，返回数组的长度。

`shift()`，删除并返回数组的第一个元素。

`splice()`，可以删除、插入、替换数组中的元素。
参数：1. 删除的起始位置。2.删除的起始位置。3.要插入的值
返回值是删除的元素。

`reverse()`，翻转数组。

`sort()`，默认按照字典序升序排列，即使是数字也会按字典序。sort参数中可以传递一个回调函数。例如`arr.sort((a,b) => a-b);`，达到升序排列目的。

## 内建对象

### 解构赋值

**数组**

假如有三个变量，分别需要赋值为数组的每一个值，可以使用语法：`let [a,b,c] = arr`。

这种赋值方法直接覆盖，如果变量多与数组元素，多余的会成为undefined。可以在解构赋值的时候设置默认值。

同样可以使用扩展符`let [a,b,...c] = arr`，这时候c会成为一个数组，里面是除去a，b的多余元素。

可以通过`[a1,a2] = [a2,a1]`来快速交换变量的值。

**对象**

和数组类似，只需要`let {a,b,c} = obj`。

可以给变量赋别名：`let {name:a,age:b,gender:c} = obj`。这样之后可以操作abc来操作新变量。

### 对象的序列化

序列化指将对象转化为一个可以储存的格式，在JS中通常是将一个对象转换为一个JSON字符串。一般用于数据交换等。

```js
//将对象转换为JSON
const str = JSON.stringfy(obj);
//将JSON转换为对象
const obj1 = JSON.parse(str);
```

由于新的obj1和旧的obj不是同一个对象，这样我们可以利用JSON实现对象的深拷贝。

```js
const obj2 = JSON.parse(JSON.stringify(obj))
```

**编写JSON字符串注意事项**

JSON有两种类型，对象和数组。注意JSON字符串中的属性名一定需要用双引号`""`包住。

JSON中可以使用的属性值：

- 数字（Number）
- 字符串（String）必须使用双引号
- 布尔值（Boolean）
- 空值（Null）
- 对象（Object {}）
- 数组（Array []）

### Map

Map用于存储键值对结构的数据。

由于对象也可以认为是一种键值对结构，那么Map和对象的区别：对象中的属性名只能是字符串或者符号Symbol()，但Map可以用任何类型的值。

创建Map：`const map = new Map()`。

添加键值对：`map.set("name","yi");map.set(obj,"ok")`。

取值：`map.get("name")`。

删除：`map.delete("name")`。

查询是否包含指定键：`map.has("name")`;

删除全部的键值对：`map.clear()`。

map的大小size是一个属性。

将Map转化为数组：`const arr = Array.from(map)`。创建好的数组是二维数组，键一个，值一个。或者用展开符`const arr = [...map]`。

遍历map：遍历的是键值对。

```js
for(const entry of map){
    let [key,vlaue] = entry;
    key...value...
}
//或者使用map的forEach方法
map.forEach((key,value) => {
    ...
})
```

获取map的所有key：`map.keys()`。返回值是一个对象。可以用for of遍历。

获取map的所有value：`map.values()`。返回值是一个对象。可以用for of遍历。

### Set

集合，和数组类似，都是有序数据，但是Set中数据不能重复。本质上就是一个Map，是一个键和值一样的Map。

创建：`const set = new Set()`;

添加数据：`set.add(10)`;

检查是否有该数据：`set.has(10)`；

将set转化为数组：`const arr = Array.from(set)`。或者用展开符`const arr = [...set]`。

遍历：`for(const item of set){...}`

可以利用set进行数组去重：`const set = new Set(arr);const arr2 = [...set]`。

删除：`set.delete("name")`。

### Math

Math是一个工具类，其中为我们提供了数学运算相关的一些常量和方法。

- 常量： Math.PI 圆周率

- 方法：

  ```javascript
  Math.abs() //求一个数的绝对值
  Math.min() //求多个值中的最小值
  Math.max() //求多个值中的最大值
  Math.pow() //求x的y次幂，也可以使用x ** y
  Math.sqrt() //求一个数的平方根
  Math.floor() //向下取整
  Math.ceil() //向上取整
  Math.round() //四舍五入取整
  Math.trunc() //直接去除小数位
  Math.random() //生成一个0-1之间的随机数
  ```

更多见[官网](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math)。

### Date

js中所有和时间相关的数据都由Date对象来表示。

创建：`let d = new Date()`，这样创建的时候是网页创建当前时间。创建指定时间可以`let d = new Date("月/日/年 时:分:秒")`或者`let d = new Date("年-月-日T时:分:秒")`或者`let d = new Date(年,月,日,时,分,秒)`

```js
getFullYear() //获取4位年份
getMonth() //返当前日期的月份（0-11）
getDate() //返回当前是几日
getDay() //返回当前日期是周几（0-6） 0表示周日
getTime() //返回当前日期对象的时间戳
/*时间戳：自1970年1月1日0时0分0秒到当前时间所经历的毫秒数,
计算机底层存储时间时，使用都是时间戳*/
Date.now() //获取当前的时间戳
```

#### 日期格式化

- d.toLocaleDateString()//将日期转化为符合语言的格式
- d.toLocaleTimeString()//将时间转化为符合语言的格式
- d.toLocaleString()//日期时间都转

这三个方法的参数第一个都是国家语言，例如`"zh-CN"`，第二个参数是一个对象，来对日期呈现的格式进行配置。具体见[官网](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString)中的option部分。

一般的option：

- 方式1：dateStyle 日期的风格，timeStyle 时间的风格：
  - 可选值
    - full
    - long
    - medium
    - short
- 方式2：{year,month,day,weekday,hour,minute,second}给各属性赋值
  - weekday 星期的显示方式：long，short，narrow
  - hour12 是否采用12小时值：true，false
  - 不写就不显示

### 包装类

也就是原始值对应的类，但是不要通过引用这些类来创建对象。

但是可以直接通过原始值来调用包装类中的方法。

### 字符串方法

- 字符串其本质就是一个字符数组
- "hello" --> ["h", "e", "l", "l", "o"]
- 字符串的很多方法都和数组是非常类似的

**属性和方法**

```javascript
length
    - 获取字符串的长度
str[索引]
    -获取指定位置的字符
str.at()
    - 根据索引获取字符，可以接受负索引
str.charAt()
    - 根据索引获取字符
str.concat("str1")
    - 用来连接两个或多个字符串，非破坏性，生成新字符串。
str.includes()
    - 用来检查字符串中是否包含某个内容，有返回true，没有返回false
str.indexOf()
str.lastIndexOf()
    - 查询字符串中是否包含某个内容,根据内容返回索引
str.startsWith()
    - 检查一个字符串是否以指定内容开头
str.endsWith()
    - 检查一个字符串是否以指定内容结尾
str.padStart(7,0)
str.padEnd(7,0)
    - 通过添加指定的内容，使字符串保持某个长度，第一个参数是长度，第二个是补位的字符
str.replace(str1,str2)
    - 使用str2替换str中的第一个str1
str.replaceAll()
    - 使用一个新字符串替换所有指定内容
str.slice(起始位置（包括）,结束位置（不包括）)
    - 对字符串进行切片
str.substring(起始位置（包括）,结束位置（不包括）)
    - 截取字符串
str.split("截取标识字符")
    - 用来将一个字符串拆分为一个数组
str.toLowerCase()
    - 将字符串转换为小写
str.toUpperCase()
    - 将字符串转换为大写
str.trim()
    - 去除前后空格
str.trimStart()
    - 去除开始空格
str.trimEnd()
    - 去除结束空格
```

### 正则表达式

正则表达式也是一个对象，需要创建。

可以通过构造函数：`let reg = new RegExp(pattern,Exp)`，第一个参数是一个正则表达式，第二个是一个标识，标识匹配模式是什么。

可以通过常量：`let reg = /a/i`，格式是：/正则/匹配模式，匹配模式可以省略。这种方式不需要写转义字符。

语法：

```
1.在正则表达式中大部分字符都可以直接写
2.| 在正则表达式中表示或
3.[] 表示或（字符集）
  [a-z] 任意的小写字母
  [A-Z] 任意的大写字母
  [a-zA-Z] 任意的字母
  [0-9]任意数字
4.[^] 表示除了
  [^x] 除了x  只要匹配到除了x的所有字符都会返回ture
5. . 表示除了换行外的任意字符
6. 在正则表达式中使用\作为转义字符
7. 其他的字符集
   \w 任意的单词字符 [A-Za-z0-9_]
   \W 除了单词字符 [^A-Za-z0-9_]
   \d 任意数字 [0-9]
   \D 除了数字 [^0-9]
   \s 空格
   \S 除了空格
   \b 单词边界
   \B 除了单词边界
8. 开头和结尾
   ^ 表示字符串的开头 
   $ 表示字符串的结尾 
   ^X$ 完全匹配，要求字符串和正则表达式完全匹配
9.量词 只匹配前一个字符，要匹配多个字符（……）{量词}
   {m} 正好m个
   {m,} 至少m个
   {m,n} m到n个
    + 一个以上，相当于{1,}
    * 任意数量
    ? 0-1次 {0,1}
10.匹配模式
   i忽略大小写
   g全局模式匹配
```

- 正则表达式.test(#字符串)检查字符串是否符合，返回ture/false
- 正则表达式.exec(#字符串) 获取字符串中符合正则表达式的内容，返回数组（可以通过在正则表达式里加括号的方式进行分组）
  - 不开全局模式此方法只会匹配第一个
  - 开了之后调一次匹配一个，下次调用从上次匹配的结尾开始
  - 同时可以使用括号在正则中对字母进行分组，括号中的内容为一组，每一次exec都会获取所有组中的内容。

#### 字符串中的正则方法

```
split()
    - 可以根据正则表达式来对一个字符串进行拆分
search()
    - 可以去搜索符合正则表达式的内容第一次在字符串中出现的位置
replace()
    - 根据正则表达式替换字符串中的指定内容
match()
    - 根据正则表达式去匹配字符串中符合要求的内容
    - 返回字符串数组
matchAll()
    - 根据正则表达式去匹配字符串中符合要求的内容(必须设置g 全局匹配)
    - 它返回的是一个迭代器，只需要对其进行遍历即可
```

### DOM

Document Object Model

文档对象模型，通过DOM可以来任意来修改网页中各个内容，DOM把JS与网页联系起来。文档指的是网页，一个网页就是一个文档；对象指将网页中的每一个节点都转换为对象， 转换完对象以后，就可以以一种纯面向对象的形式来操作网页了；模型用来表示节点和节点之间的关系，方便操作页面。

节点（Node） 节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点。虽然都是节点，但是节点的类型却是不同的。Node对象是所有DOM对象的祖先。

#### 文档节点

浏览器已经为我们提供了一个document对象，表示整个网页，通过这个对象来操作整个网页。

原型链：HTMLDocument -> Document -> Node -> EventTarget -> Object.prototype -> null

部分属性：

- document.documentElement --> html根元素
- document.head --> head元素
- document.title --> title元素
- document.body --> body元素
- document.links --> 获取页面中所有的超链接

#### 元素节点

代表的是每一个标签。每一个标签都是一个元素节点。

获取元素节点：

1. document.getElementById()
   - 根据id获取一个元素节点对象
2. document.getElementsByClassName()
   - 根据元素的class属性值获取一组元素节点对象
   - 返回的是一个类数组对象
   - 该方法返回的结果是一个实时更新的集合，当网页中新添加元素时，集合也会实时的刷新
3. document.getElementsByTagName()
   - 根据标签名获取一组元素节点对象
   - 返回的结果是可以实时更新的集合
   - document.getElementsByTagName("*") 获取页面中所有的元素
4. document.getElementsByName()
   - 根据name属性获取一组元素节点对象
   - 返回一个实时更新的集合
   - 主要用于表单项
5. document.querySelectorAll()
   - 根据选择器去页面中查询元素
   - 会返回一个类数组（不会实时更新）
   - 不会实时更新元素节点的改变，但属性节点和文本节点的改变会更新
6. document.querySelector()
   - 根据选择器去页面中查询第一个符合条件的元素

通过document对象来创建元素节点：`document.createElement("标签名")`根据标签名创建一个元素节点对象。

##### 属性和方法

```js
//通过元素节点对象获取其他节点的方法
element.getElementsByTagName()
element.childNodes//获取当前元素的子节点（会包含空白的子节点）
element.children//获取当前元素的子元素
element.firstElementChild//获取当前元素的第一个子元素
element.lastElementChild//获取当前元素的最后一个子元素
element.nextElementSibling//获取当前元素的下一个兄弟元素
element.previousElementSibling//获取当前元素的前一个兄弟元素
element.parentNode//获取当前元素的父节点
element.tagName//获取当前元素的标签名
```

#### 文本节点

一般不直接获取文本对象，而是通过元素来修改其中的文本。

三个属性：

element.textContent，读取或者修改元素中的文本内容；不会考虑css样式；

element.innerText，读取或者修改元素中的文本内容；会考虑css样式，所以会触发网页计算css样式，性能比textcontent差；

element.innerHTML，读取或者修改元素中的标签；但是使用有xss注入风险。

#### 属性节点

属性就是标签中添加的属性。

操作方法：

- 方式一：
  - 读取：元素.属性名
    - 注意：class属性的属性名是className
    - 读取一个布尔值时，会返回true或false
  - 修改：元素.属性名 = 属性值
- 方式二：
  - 读取：元素.getAttribute(属性名)
  - 修改：元素.setAttribute(属性名, 属性值)
  - 删除：元素.removeAttribute(属性名)

#### 事件

- 事件就是用户和页面之间发生的交互行为 比如：点击按钮、鼠标移动、双击按钮、敲击键盘、松开按键...
- 可以通过为事件绑定响应函数（回调函数），来完成和用户之间的交互
- 绑定响应函数的方式：
  - 1.可以直接在元素的属性中设置
  - 2.可以通过为元素的指定属性设置回调函数的形式来绑定事件（一个事件只能绑定一个响应函数），例如`btn.onclick = function(){...}`
  - 3.可以通过元素`addEventListener("click",function({}))`方法来绑定事件
    - 添加事件监听器，一个事件能绑定多个响应函数
- 在事件的响应函数中，响应函数绑定给谁 this就是谁（箭头函数除外）
- 采用addEventListener()绑定的事件可以解绑，使用`removeEventListener(参数与绑定方法一致)`

#### 事件对象

事件对象是有浏览器在事件触发的时候创建的对象，其中包含了事件的各种具体信息。可以获取到鼠标坐标、键盘按键等等。

浏览器在创建事件对象之后，会将其作为一个参数传递到相应函数的参数中。可以`box1.onmousemove = event => {...}`或者`box1.addEventListener("mousemove",function(event){...})`这个event就是事件对象。

事件对象也是有分类以及相互之间的继承的，具体可以看mdn。所有的事件对象的共同祖先都是Event。

`event.x`鼠标的x坐标。

##### 触发事件对象

`event.target`，触发事件的对象。但是触发事件的对象并不一定是绑定事件的对象。如果使用this，就一定是绑定事件的对象，同时`event.currentTarget`和this一样，也是绑定事件的对象。

##### 事件触发阶段

事件触发的顺序：

1. 捕获阶段
2. 目标阶段
3. 冒泡阶段

可以通过`event.eventPhase`查看事件的阶段。值为1是捕获阶段，2是目标阶段，3是捕获阶段。不过没啥用。

##### 事件冒泡

事件冒泡就是事件的向上传递，当元素的某个事件触发后，其祖先元素上的相同事件也会同时触发。

有时候不想要事件冒泡，可以通过事件对象来取消冒泡：在相应的事件响应函数中使用`event.stopPropagation()`，可以停止事件传递。

##### 取消事件默认行为

在事件响应函数中使用`event.preventDefault()`，可以取消默认行为，例如超链接的跳转。

##### 事件的委派

有时候我们会有需求，例如添加新的元素，但是有可能会出现新的元素没有之前的同种元素绑定的事件。这时候可以使用事件的委派。也就是将事件绑定给父元素乃至祖先元素。我们一般会直接绑定给document整个网页。

但是直接给document绑定事件，会导致点击本来不是事件目标的元素也会有相应的响应，解决方案是在响应函数中首先对`event.target`进行判断，如果在想要的目标中，响应函数的相关部分就执行。

##### 事件的捕获

事件的捕获指事件从外向内的传导，当前元素触发事件后，会从事件最大的祖先元素从外向内进行事件的捕获。捕获在捕获到目标元素后结束，然后进行事件的冒泡。像是一个事件栈。

如果希望在捕获阶段就触发事件，可以在addEventListener方法中添加第三个参数true，实现在捕获阶段触发。

#### 修改dom

- 增

  - appendChild() 用于给一个节点添加子节点

  - insertAdjacentElement()可以向元素的任意位置添加元素 `<br/>` 两个参数：

    要添加的位置

    ```javascript
    beforeend 标签的最后
    afterbegin 标签的开始
    beforebegin 在元素的前边插入元素（兄弟元素）
    afterend 在元素的后边插入元素（兄弟元素）
    ```

    要添加的元素对象

  - insertAdjacentHTML("要添加的位置", "html代码");

- 删

  - 元素.remove()

- 改

  - 被替换元素.replaceWith(替换元素)

**事件中可以通过取消默认行为来阻止超链接的跳转，在事件绑定函数中return false来取消默认行为，只在 xxx.xxx = function(){}这种形式绑定的事件中才适用**

#### 节点复制

节点对象的cloneNode()方法。当时这个方法复制节点时会复制节点的所有特点。包括各种属性，但是只会复制节点，不会复制子节点。

如果要同时复制节点中的文字，或者是同时复制其中的子节点，只需要传入一个参数为`true`。

#### CSS样式调整

##### 修改

**直接修改**

元素.style.样式名 = 样式值。例如`box1.style.width = "200px"`。这种修改相当于增加了一个内联样式，优先级等同于内联样式。

注意如果样式名中有`-`，需要将其修改为小驼峰命名。

**通过class修改**

可以通过给元素节点的className属性添加一个新的类或者直接修改其值，来达到修改css的目的。但是不建议使用，建议用list

例如`box1.className += " box2"`。

通过`元素.classList`来修改，这是一个对象，对象中包括了当前元素的类的各种操作方法：

```js
box1.classList.add("box2");
box1.classList.remove("box2");
box1.classList.toggle("box2");//切换，如果有就修改没，如果没就修改有，可以用于多次切换。但是一次只能操作一个class
box1.classList.replace("box1","box2");//替换
box1.classList.contains("box2");//检查是否包含
```

##### 读取

**方法**

`getComputedStyle()`，直接用即可，不是哪个对象的方法，得到当前节点对象生效的所有样式对象。可以通过返回的对象.属性名，来读取相应样式。

其参数第一个是要获取样式的节点对象，第二个是伪元素（如果需要）。

读取的样式值有可能会是auto，但是也有可能不是，需要验证之后再进行运算。

**属性**

通过属性获得的值会自动去掉单位。一般都是只读的。

元素.clientHeight、元素.clientWidth：获取元素的宽高，包括内容区和内边距；

元素.offsetHeight、元素.offsetWidth：获取元素的宽高，包括内容区和内边距和边框；

元素.scrollHeight、元素.scrollWidth：获取元素滚动区域的宽高；

元素.offsetParent，获取元素的定位父元素。也就是里当前元素的最近的开启了定位的祖先元素。

元素.offsetLeft、元素.offsetTop，获取元素相对于定位父元素的偏移量。

元素.scrollLeft、元素.scrollTop，获取元素滚动条已经滚动的偏移量。这个值可以被设置、修改。

### BOM

浏览器对象模型。它为我们提供了一组对象，可以实现对浏览器的各种操作。

- Window：代表浏览器窗口
- Navigator：浏览器的对象，可以操作浏览器
- Location：浏览器的地址栏信息
- History：浏览器历史记录，只能读取用户访问了几个网页，用来控制浏览器前进后退。
- Screen：屏幕的信息。

BOM对象都是作为window对象的属性保存的，所以可以直接访问，不需要先获取对象。

#### Navigator

比较常用的`Navigator.userAgent()`，返回一个用来描述浏览器信息的字符串。

其他用的时候看mdn。

#### Location

location.href获取地址信息。

`location.assign("一个地址")`，跳转到新地址。

`location.replace("一个地址")`，跳转到新地址，无法通过回退按钮回退，因为替换不会产生历史。

`location.reload()`，刷新页面。传入参数true，可以强制清除缓存。

#### History

`history.back()`，回退。

`history.forward()`，前进。

`history.go()`，传入正值，传几就前进几，负值就是后退几。

## 其他杂项

### unicode编码

html中编码前面加`&#`,js中前面加`\u`。

### switch小技巧

```js
switch(true){
    case a > 1:
        ....
        break;
    default:
        ....
}
```

### 严格模式

在想要开启严格模式的作用域开头写`"use strict"`。能提升代码运行的性能。

类自带严格模式。

### 声明提升

使用var声明的变量，是在所有代码执行之前声明，但不会赋值。在声明前也可以访问。如果不使用var，就不会被提前声明。

使用function关键字声明的函数，会在所有代码执行之前声明，可以被任意调用，但是使用var声明的函数不会被提前创建。

let声明的变量也会提升，但是在赋值前禁止访问。

#### let和var和const

var声明的变量没有块作用域，在代码块外面访问一个在代码块内声明的变量也能访问到。最好用let。但是有函数作用域，在函数外部访问不到函数内部var声明的变量。

const是常量，只能被赋值一次，一些不希望被改变的对象可以声明为只读。但是对象的属性可以被修改。

要注意如果在局部变量中没有用var或者let声明变量，直接写一个`a=10;`，就会成为全局变量。相当于写`window.a=10`。

#### debug断点

代码中写一行debugger。

### this关键字

在函数中调用，this指向的是window。通过对象调用，以方法的形式调用，this指向的是对象。

箭头函数没有自己的this，和他的调用方式无关，只和其外层作用域有关。外层是谁，this就是谁。

### 浅拷贝和深拷贝

#### 浅拷贝

通常对对象的拷贝都是浅拷贝，浅拷贝就是只拷贝一层。如果对象中只有原始值，那拷贝的深浅不重要。
浅拷贝只会对对象本身进行复制，不会复制对象中的属性或元素。也就是如果对象中还有对象，对第一层对象进行复制，就只是会多出来一个第一层对象，这个多出来的第一层对象中包含的那个对象还是原来的那个。

那么如果修改浅拷贝的对象中包含的对象，则其他的也会收到影响。

**浅拷贝方式**

1. 数组的slice()方法。
2. 使用`...`展开运算符。可以将一个数组中的元素展开到另一个数组中或者作为函数的参数传递。`const arr2 = [...arr]`，同时可以进行添加元素。
   同理可以对对象使用该运算符。`const obj2 = {...obj}`。但是在添加属性的时候，添加在展开运算符后面的属性会覆盖展开中的内容。
3. 使用Object中的assign方法。`const obj2 = Object.assign({},obj)`。就是将obj对象中的属性复制给`{}`新对象。

#### 深拷贝

不止复制对象本身，还会复制对象的属性和元素。

**深拷贝方法**：structureClone()。直接写`const arr2 = structureClone(arr)`。

const obj2 = JSON.parse(JSON.stringify(obj))

### 解决xss注入

手动创建元素节点及其内容，之后获取要添加的元素对象，手动添加。

### 定时器

设置方式：

1. `setTimeout()`，参数第一个是回调函数，就是要执行的函数，第二个是指定的时间，单位是毫秒。有一个返回值，作为定时器的编号。`clearTimeout()`，传入对应计时器的编号，可以关闭响应的计时器。
2. `setInterval()`，参数一样，但是这个是无限循环，每间隔一段时间就会执行。可以利用这一点来控制多次执行。在执行次数达到目标的时候`clearInterval()`。

定时器的本质是在指定时间之后将函数插入到消息队列中。setInterval也是每隔一定时间就将回调函数入队，那么如果 回调函数执行时间过长，会导致无法确保时间间隔相等。所以一般不会直接使用setInterval。可以使用setTimeout模拟：

```js
setTimeout(function fn(){
    ...
    ...
    //在最后
    setTimeout(fn,3000);
},3000)
```

### 消息队列

消息队列负责存放将要执行的函数。

当事件触发的时候，并不是立刻将响应函数推到函数栈中，而是先进消息队列。在函数栈空后才会执行。
